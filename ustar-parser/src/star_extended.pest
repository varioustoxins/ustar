
// vertical_tab = _{ "\u{000B}" } // though Hall defines the vertical tab its of no practical use...
DOLLAR = _{ "$" }

NEWLINE_CHAR = {"\n"}
CARRIAGE_RETURN_CHAR  = {"\r"}
UNIX_NEWLINE = {NEWLINE_CHAR}
WINDOWS_NEWLINE = @{CARRIAGE_RETURN_CHAR ~ NEWLINE_CHAR}
NEWLINE = @{UNIX_NEWLINE | WINDOWS_NEWLINE}
SEMICOLON = {";"}

// Character class placeholders - replaced by build.rs based on encoding mode
BLANK = _{ " " | "\t" | "\u{00A0}" }  // we separate simple spaces and end of line spaces
UTF8_BOM = _{ "\u{FEFF}" }  // UTF-8 BOM detection (Unicode mode only)

NEWLINE_SEMICOLON = @{NEWLINE ~ SEMICOLON}
BASIC_WHITESPACE = _{ BLANK | NEWLINE }
WHITESPACE = _{ !NEWLINE_SEMICOLON ~ BASIC_WHITESPACE}
COMMENT = _{ "#" ~ (!"\n" ~ ANY)* ~ (!("\n" ~ ";") ~ "\n" | EOI) }

NON_BLANK_CHAR_NO_QUOTES = { '\u{21}'..'\u{26}' | '\u{28}'..'\u{FF}' }  // it makes it complicated if quotes are in here
NO_BLANK_CHAR = { '\u{21}'..'\u{FF}' }
DOUBLE_QUOTE = {"\""}
SINGLE_QUOTE = {"'"}
TWO_DOUBLE_QUOTE_CHARS = @{DOUBLE_QUOTE ~ DOUBLE_QUOTE}
TWO_SINGLE_QUOTE_CHARS = @{SINGLE_QUOTE ~ SINGLE_QUOTE}

CHAR = {BLANK | NON_BLANK_CHAR_NO_QUOTES}
SEMICOLON_QUOTED_CHAR = { CHAR | DOUBLE_QUOTE | SINGLE_QUOTE | NEWLINE  }
UNDERSCORE = {"_"}

// the data keyword which is case insensitive
data_anycase = _{^"data"}
data_keyword = @{data_anycase ~ UNDERSCORE}

loop_anycase = _{^"loop"}
loop_keyword = @{loop_anycase ~ UNDERSCORE}

global_anycase = _{^"global"}
global_keyword = @{global_anycase ~ UNDERSCORE}

// the save keyword which is case insensitive
save_anycase = _{^"save"}
save_keyword = @{save_anycase ~ UNDERSCORE}

stop_anycase = _{^"stop"}
stop_keyword = @{stop_anycase ~ UNDERSCORE}

key_words = _{data_keyword | loop_keyword | global_keyword | save_keyword | stop_keyword}

// a name of the form _ABC
data_name = @{UNDERSCORE ~ NO_BLANK_CHAR+}

// a value which doesn't start with _ $ and isn't save_ or a loop initialiser
non_quoted_string = @{!UNDERSCORE ~ !DOLLAR  ~ NON_BLANK_CHAR_NO_QUOTES ~ NO_BLANK_CHAR*}
// Hall doesn't note that a non_quoted_text_string can't start with an _ or  dollar and cant be save_?
// or do i have this wrong

// a double quoted string -  note there should be ways to write this closer to the original gammar
// <double_quoted_text_string> ::= <D_quote> <D_quote_string> <D_quote>
// D_quote_string ::= {<D_quote> <non_blank_char> | * <not_a_D_quote>}
double_quote_string = @{DOUBLE_QUOTE ~ double_quote_string_inner* ~ DOUBLE_QUOTE }
double_quote_end = @{DOUBLE_QUOTE ~ (BLANK|EOI|NEWLINE)}
double_quote_string_inner = @{ !double_quote_end ~ (NON_BLANK_CHAR_NO_QUOTES | SINGLE_QUOTE | double_quote_inner | BLANK) }
double_quote_inner = @{DOUBLE_QUOTE ~ NON_BLANK_CHAR_NO_QUOTES | NON_BLANK_CHAR_NO_QUOTES ~ DOUBLE_QUOTE |  two_double_quotes_not_end | TWO_DOUBLE_QUOTE_CHARS}
two_double_quotes_end = @{TWO_DOUBLE_QUOTE_CHARS ~ (BLANK|EOI|NEWLINE)}
two_double_quotes_not_end = @{&two_double_quotes_end ~ DOUBLE_QUOTE}

// a single quoted string - note there should be ways to write this closer to the original gammar
// <single_quoted_text_string> ::= <S_quote> <S_quote_string> <S_quote>
// S_quote_string ::= {<S_quote> <non_blank_char> | * <not_a_S_quote>
single_quote_string = @{SINGLE_QUOTE ~ single_quote_string_inner* ~ SINGLE_QUOTE }
single_quote_end = @{SINGLE_QUOTE ~ (BLANK|EOI|NEWLINE)}
single_quote_string_inner = @{ !single_quote_end ~ (NON_BLANK_CHAR_NO_QUOTES | DOUBLE_QUOTE | single_quote_inner| BLANK) }
single_quote_inner = @{SINGLE_QUOTE ~ NON_BLANK_CHAR_NO_QUOTES | NON_BLANK_CHAR_NO_QUOTES ~ SINGLE_QUOTE |  two_single_quotes_not_end | TWO_SINGLE_QUOTE_CHARS}
two_single_quotes_end = @{TWO_SINGLE_QUOTE_CHARS ~ (BLANK|EOI|NEWLINE)}
two_single_quotes_not_end = @{&two_single_quotes_end ~ SINGLE_QUOTE}

// a frame code
frame_code = @{DOLLAR ~ NON_BLANK_CHAR_NO_QUOTES+}

// For semicolon-bounded text, we need to distinguish between:
// 1. Lines with content that can contain semicolons anywhere EXCEPT as first character
// 2. A line that starts with ; AS THE FIRST CHARACTER (terminates the text)  
// CRITICAL: terminator requires ; at position 0 with NO preceding whitespace
// semicolon_text_char = { !new_line ~ semi_colon_quoted_char }
// For semicolon-bounded text: character by character approach (ASCII only)
semicolon_text_content = @{ (!NEWLINE_SEMICOLON ~ SEMICOLON_QUOTED_CHAR)* }

semi_colon_string = @{
    NEWLINE_SEMICOLON ~
    semicolon_text_content ~
    NEWLINE_SEMICOLON
}

// a group of values
// note as per 10a the values data_ loop_ global_ save_ and stop_ are not allowed as they are keywords
// to use them you have to wrap them in a string
data_value = _{
    !key_words
    ~ non_quoted_string
    | semi_colon_string
    | double_quote_string
    | single_quote_string
    | frame_code
}

// heading of a data block of
// <global_heading> ::= global_
// global_heading = @{global_keyword}

// <global_block> ::= <global_heading> <data_block_body>+
global_block = {global_keyword ~ global_block_body+}

// <global_block_body> ::= <data>+
global_block_body = _{data+}

// a data item
data = {data_name ~ data_value | data_loop}

// heading of a data block of the form data_***
data_heading = @{data_keyword  ~ NO_BLANK_CHAR+}

// a data block of the form data_*** ...
data_block = {data_heading ~ data_block_body+} 

// the body of a data block containing data [data_names and data_values] or save frames
data_block_body =  _{data | save_frame}  // move plus to 1. above ?

// heading for a save_frame
// save_heading ::= save_<<non_blank_char>+e>
save_heading = @{save_keyword ~ NO_BLANK_CHAR+}

// save frame
// save_frame ::= <save_heading> <data>+ save_
save_frame = {save_heading ~ data+ ~ save_keyword}


// data_loop
// data_loop ::= loop_ <data_loop_definition> <data_loop_values>
data_loop = {loop_keyword ~ data_loop_definition ~ data_loop_values}

// <data_loop_definition>  ::= <data_loop_field>+
data_loop_definition = {data_loop_field+}

//<nested_loop> ::= loop_ <data_loop_definition> [stop_]
nested_loop = {loop_keyword ~ data_name ~ data_loop_field+ ~ stop_keyword{0,1} }

// <data_loop_field> ::= <data_name> | <nested_loop>
data_loop_field = _{data_name | nested_loop}

// <data_loop_values> ::= <data_loop_item>+
data_loop_values = {data_loop_item+}

// <data_loop_item> ::= <data_value> | stop_
data_loop_item = _{stop_keyword | data_value }

// star file
// <star-file> ::= {<data_block> I <global_block> }*
data_block_or_global_block = _{data_block | global_block}

star_file = {SOI ~ UTF8_BOM? ~ data_block_or_global_block* ~ EOI }
