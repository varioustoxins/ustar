
// vertical_tab = _{ "\u{000B}" } // though Hall defines the vertical tab its of no practical use...
DOLLAR = _{ "$" }
BLANK = _{ " " | "\t" }  // we separate simple spaces and end of line spaces, this doesn't contain a vertical tab vide supra

NEWLINE = {"\n"}
SEMICOLON = {";"}
NEWLINE_SEMICOLON = @{NEWLINE ~ SEMICOLON}
BASIC_WHITESPACE = _{ BLANK | "\n" | "\r" }
WHITESPACE = _{ !NEWLINE_SEMICOLON ~ BASIC_WHITESPACE}
COMMENT = _{ "#" ~ (!"\n" ~ ANY)* ~ "\n" }

NON_BLANK_CHAR_NO_QUOTES = { "!" | '#'..'&' |  '('..'~' }  // it makes it complicated if quotes are in here
NO_BLANK_CHAR = { '!'..'~' }
DOUBLE_QUOTE = _{"\""}
SINGLE_QUOTE = _{"'"}
SINGLE_QUOTE_CHAR = {"'"}
DOUBLE_QUOTE_CHAR = {"\""}
TWO_SINGLE_QUOTE_CHARS = {"''"}
TWO_DOUBLE_QUOTE_CHARS = {"\"\""}


CHAR = {BLANK | NON_BLANK_CHAR_NO_QUOTES}
SEMICOLON_QUOTED_CHAR = { CHAR | DOUBLE_QUOTE | SINGLE_QUOTE | NEWLINE | "\r" }
UNDERSCORE = {"_"}

// the data keyword which is case insensitive
data_anycase = _{^"data"}
data_keyword = @{data_anycase ~ UNDERSCORE}

loop_anycase = _{^"loop"}
loop_keyword = @{loop_anycase ~ UNDERSCORE}

global_anycase = _{^"global"}
global_keyword = @{global_anycase ~ UNDERSCORE}

// the save keyword which is case insensitive
save_anycase = _{^"save"}
save_keyword = @{save_anycase ~ UNDERSCORE}

stop_anycase = _{^"stop"}
stop_keyword = @{stop_anycase ~ UNDERSCORE}

key_words = _{data_keyword | loop_keyword | global_keyword | save_keyword | stop_keyword}

// a name of the form _ABC
data_name = @{UNDERSCORE ~ NO_BLANK_CHAR+}

// a value which doesn't start with _ $ and isn't save_ or a loop initialiser
non_quoted_text_string = @{!UNDERSCORE ~ !DOLLAR ~ NON_BLANK_CHAR_NO_QUOTES+}
// Hall doesn't note that a non_quoted_text_string can't start with an _ or  dollar and cant be save_?
// or do i have thus wrong

// a double quoted string 
// <double_quoted_text_string> ::= <D_quote> <D_quote_string> <D_quote>
// D_quote_string ::= {<D_quote> <non_blank_char> | * <not_a_D_quote>
// NOTE: this is writtens so that double quoted text string can contain anything except "<SPACE>|EOI|NEWLINE"
double_quote_string = @{DOUBLE_QUOTE ~ double_quote_string_inner* ~ DOUBLE_QUOTE }
double_quote_end = @{DOUBLE_QUOTE ~ (BLANK|EOI|NEWLINE)}
double_quote_inner = @{SINGLE_QUOTE_CHAR ~ NON_BLANK_CHAR_NO_QUOTES | NON_BLANK_CHAR_NO_QUOTES ~ DOUBLE_QUOTE_CHAR |  TWO_DOUBLE_QUOTE_CHARS}
double_quote_string_inner = @{ !double_quote_end ~ (NON_BLANK_CHAR_NO_QUOTES | SINGLE_QUOTE_CHAR  | double_quote_inner | BLANK) }

// a single quoted string
// <single_quoted_text_string> ::= <S_quote> <S_quote_string> <S_quote>
// S_quote_string ::= {<S_quote> <non_blank_char> | * <not_a_S_quote>
// NOTE: this is writtens so that single quoted text string can contain anything except '<SPACE>|EOI|NEWLINE"
single_quote_string = @{SINGLE_QUOTE ~ single_quote_string_inner* ~ SINGLE_QUOTE }
single_quote_end = @{SINGLE_QUOTE ~ (BLANK|EOI|NEWLINE)}
single_quote_inner = @{SINGLE_QUOTE_CHAR ~ NON_BLANK_CHAR_NO_QUOTES | NON_BLANK_CHAR_NO_QUOTES ~ SINGLE_QUOTE_CHAR |  TWO_SINGLE_QUOTE_CHARS}
single_quote_string_inner = @{ !single_quote_end ~ (NON_BLANK_CHAR_NO_QUOTES | DOUBLE_QUOTE_CHAR  | single_quote_inner| BLANK) }

// a frame code
frame_code = @{DOLLAR ~ NON_BLANK_CHAR_NO_QUOTES+}

// For semicolon-bounded text, we need to distinguish between:
// 1. Lines with content that can contain semicolons anywhere EXCEPT as first character
// 2. A line that starts with ; AS THE FIRST CHARACTER (terminates the text)  
// CRITICAL: terminator requires ; at position 0 with NO preceding whitespace
// For semicolon-bounded text: character by character approach (ASCII only)
semi_colon_bounded_text_string = {
    NEWLINE_SEMICOLON ~
    semicolon_text_content ~
    NEWLINE_SEMICOLON
}
semicolon_text_content = @{ (!NEWLINE_SEMICOLON ~ SEMICOLON_QUOTED_CHAR)* }

// a group of values
// note as per 10a the values data_ loop_ global_ save_ and stop_ are not allowed as they are keywords
// to use them you have to wrap them in a string
data_value = _{
    !key_words
    ~ non_quoted_text_string
    | semi_colon_bounded_text_string
    | double_quote_string
    | single_quote_string
    | frame_code
}

// heading of a data block of
// <global_heading> ::= global_
// global_heading = @{global_keyword}
// <global_block> ::= <global_heading> <data_block_body>+
global_block = {global_keyword ~ global_block_body+}

// <global_block_body> ::= <data>+
global_block_body = _{data+}

// a data item
data = {data_name ~ data_value | data_loop}

// heading of a data block of the form data_***
data_heading = @{data_keyword  ~ NO_BLANK_CHAR+}

// a data block of the form data_*** ...
data_block = {data_heading ~ data_block_body+} // 1. place to move + to

// the body of a data block containing data [data_names and data_values] or save frames
data_block_body =  _{data | save_frame}  // move plus to 1. above ?

// heading for a save_frame
// save_heading ::= save_<<non_blank_char>+e>
save_heading = @{save_keyword ~ NO_BLANK_CHAR+}

// save frame
// save_frame ::= <save_heading> <data>+ save_
save_frame = {save_heading ~ data+ ~ save_keyword}


// data_loop
// data_loop ::= loop_ <data_loop_definition> <data_loop_values>
data_loop = {loop_keyword ~ data_loop_definition ~ data_loop_values}

// <data_loop_definition>  ::= <data_loop_field>+
data_loop_definition = {data_loop_field+}

//<nested_loop> ::= loop_ <data_loop_definition> [stop_]
nested_loop = {loop_keyword ~ data_name ~ data_loop_field+ ~ stop_keyword{0,1} }

// <data_loop_field> ::= <data_name> | <nested_loop>
data_loop_field = _{data_name | nested_loop}

// <data_loop_values> ::= <data_loop_item>+
data_loop_values = {data_loop_item+}

// <data_loop_item> ::= <data_value> | stop_
data_loop_item = _{stop_keyword | data_value }

// star file
// <star-file> ::= {<data_block> I <global_block> }*
data_block_or_global_block = _{data_block | global_block}

star_file = {SOI ~ data_block_or_global_block* ~ EOI}
